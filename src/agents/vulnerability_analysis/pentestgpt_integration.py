#!/usr/bin/env python3
"""
PentestGPT Integration for AegisLearner-AI
Advanced AI-powered penetration testing capabilities with GPT models
"""

import json
import asyncio
import logging
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, asdict
from datetime import datetime
import subprocess
import os
import requests
from pathlib import Path

@dataclass
class PentestTask:
    """Represents a penetration testing task"""
    task_id: str
    task_type: str  # 'reconnaissance', 'vulnerability_scan', 'exploitation', 'post_exploitation'
    target: str
    parameters: Dict[str, Any]
    priority: int = 1
    status: str = "pending"
    created_at: str = ""

    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.utcnow().isoformat()

@dataclass
class PentestResult:
    """Represents penetration testing results"""
    task_id: str
    findings: List[Dict[str, Any]]
    recommendations: List[str]
    risk_score: float
    execution_time: float
    success: bool
    error_message: Optional[str] = None

class PentestGPTAgent:
    """Advanced AI-powered penetration testing agent"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.logger = logging.getLogger(__name__)
        self.session = requests.Session()
        self.knowledge_base = {}
        self.exploit_database = {}

        # Initialize AI models for different pentest phases
        self.reconnaissance_prompts = self._load_reconnaissance_prompts()
        self.vulnerability_prompts = self._load_vulnerability_prompts()
        self.exploitation_prompts = self._load_exploitation_prompts()

    def _load_reconnaissance_prompts(self) -> Dict[str, str]:
        """Load AI prompts for reconnaissance phase"""
        return {
            "subdomain_enum": """
            You are a penetration tester performing subdomain enumeration on {target}.
            Analyze the target and suggest the best tools and techniques for comprehensive subdomain discovery.
            Consider:
            1. Passive enumeration techniques
            2. Active enumeration methods
            3. DNS brute forcing strategies
            4. Certificate transparency logs
            5. Search engine dorking

            Provide a detailed reconnaissance plan with specific commands and expected outcomes.
            """,

            "port_scanning": """
            You are conducting a port scan on {target} with discovered subdomains: {subdomains}.
            Design an optimal port scanning strategy that:
            1. Minimizes detection while maximizing coverage
            2. Uses appropriate timing and evasion techniques
            3. Focuses on common and uncommon service ports
            4. Includes UDP scanning for critical services

            Provide specific nmap commands and scanning methodology.
            """,

            "service_enumeration": """
            You discovered these open ports on {target}: {ports}.
            For each service, provide:
            1. Version detection strategies
            2. Service-specific enumeration techniques
            3. Common vulnerabilities to check
            4. Exploitation possibilities

            Focus on practical attack vectors and provide specific commands.
            """
        }

    def _load_vulnerability_prompts(self) -> Dict[str, str]:
        """Load AI prompts for vulnerability analysis"""
        return {
            "web_application": """
            You are analyzing a web application at {target} with these technologies: {tech_stack}.
            Conduct a comprehensive vulnerability assessment covering:
            1. OWASP Top 10 vulnerabilities
            2. Input validation flaws
            3. Authentication and session management
            4. Business logic vulnerabilities
            5. Client-side vulnerabilities

            Provide specific test cases and exploitation techniques for each vulnerability type.
            """,

            "network_services": """
            You identified these network services: {services}.
            For each service, analyze:
            1. Known CVEs and security advisories
            2. Misconfigurations and weak settings
            3. Protocol-specific vulnerabilities
            4. Privilege escalation opportunities

            Prioritize findings by exploitability and impact.
            """,

            "infrastructure": """
            The target infrastructure includes: {infrastructure}.
            Assess:
            1. Cloud misconfigurations
            2. Network segmentation issues
            3. Monitoring and logging gaps
            4. Backup and recovery vulnerabilities

            Focus on high-impact infrastructure vulnerabilities.
            """
        }

    def _load_exploitation_prompts(self) -> Dict[str, str]:
        """Load AI prompts for exploitation phase"""
        return {
            "exploit_development": """
            You found this vulnerability: {vulnerability}.
            Target details: {target_info}

            Develop a comprehensive exploitation strategy:
            1. Exploit development approach
            2. Payload crafting techniques
            3. Evasion and bypass methods
            4. Post-exploitation activities

            Provide working exploit code and detailed execution steps.
            """,

            "privilege_escalation": """
            You have {access_level} access on {target}.
            System information: {system_info}

            Identify privilege escalation opportunities:
            1. Kernel exploits
            2. Service misconfigurations
            3. SUID/SGID binaries
            4. Scheduled tasks and cron jobs
            5. Environment variables and paths

            Provide step-by-step escalation techniques.
            """,

            "lateral_movement": """
            You compromised {current_host} in the network.
            Network topology: {network_info}

            Plan lateral movement strategy:
            1. Network reconnaissance from compromised host
            2. Credential harvesting techniques
            3. Movement techniques (SMB, WMI, SSH)
            4. Persistence mechanisms

            Provide specific commands and tools for each phase.
            """
        }

    async def execute_pentest_task(self, task: PentestTask) -> PentestResult:
        """Execute a penetration testing task using AI guidance"""
        try:
            start_time = datetime.utcnow()

            if task.task_type == "reconnaissance":
                result = await self._execute_reconnaissance(task)
            elif task.task_type == "vulnerability_scan":
                result = await self._execute_vulnerability_scan(task)
            elif task.task_type == "exploitation":
                result = await self._execute_exploitation(task)
            elif task.task_type == "post_exploitation":
                result = await self._execute_post_exploitation(task)
            else:
                raise ValueError(f"Unknown task type: {task.task_type}")

            execution_time = (datetime.utcnow() - start_time).total_seconds()

            return PentestResult(
                task_id=task.task_id,
                findings=result.get("findings", []),
                recommendations=result.get("recommendations", []),
                risk_score=result.get("risk_score", 0.0),
                execution_time=execution_time,
                success=True
            )

        except Exception as e:
            self.logger.error(f"Error executing pentest task {task.task_id}: {str(e)}")
            return PentestResult(
                task_id=task.task_id,
                findings=[],
                recommendations=[],
                risk_score=0.0,
                execution_time=0.0,
                success=False,
                error_message=str(e)
            )

    async def _execute_reconnaissance(self, task: PentestTask) -> Dict[str, Any]:
        """Execute reconnaissance phase with AI guidance"""
        target = task.target
        findings = []
        recommendations = []

        # Subdomain enumeration with AI strategy
        subdomain_strategy = await self._get_ai_strategy(
            "reconnaissance", "subdomain_enum", {"target": target}
        )
        subdomains = await self._perform_subdomain_enumeration(target, subdomain_strategy)

        if subdomains:
            findings.append({
                "type": "subdomain_discovery",
                "count": len(subdomains),
                "subdomains": subdomains[:10],  # Limit output
                "severity": "informational"
            })

        # Port scanning with AI optimization
        port_strategy = await self._get_ai_strategy(
            "reconnaissance", "port_scanning",
            {"target": target, "subdomains": subdomains[:5]}
        )
        open_ports = await self._perform_port_scanning(target, port_strategy)

        if open_ports:
            findings.append({
                "type": "open_ports",
                "ports": open_ports,
                "severity": "informational"
            })

        # Service enumeration with AI analysis
        if open_ports:
            service_strategy = await self._get_ai_strategy(
                "reconnaissance", "service_enumeration",
                {"target": target, "ports": open_ports}
            )
            services = await self._perform_service_enumeration(target, open_ports, service_strategy)

            if services:
                findings.append({
                    "type": "service_discovery",
                    "services": services,
                    "severity": "informational"
                })

        # Generate AI-powered recommendations
        recommendations = await self._generate_reconnaissance_recommendations(findings)

        return {
            "findings": findings,
            "recommendations": recommendations,
            "risk_score": self._calculate_reconnaissance_risk_score(findings)
        }

    async def _execute_vulnerability_scan(self, task: PentestTask) -> Dict[str, Any]:
        """Execute vulnerability scanning with AI analysis"""
        target = task.target
        scan_type = task.parameters.get("scan_type", "web_application")
        findings = []
        recommendations = []

        if scan_type == "web_application":
            # AI-guided web application testing
            tech_stack = task.parameters.get("tech_stack", [])
            web_strategy = await self._get_ai_strategy(
                "vulnerability", "web_application",
                {"target": target, "tech_stack": tech_stack}
            )
            web_vulns = await self._perform_web_vulnerability_scan(target, web_strategy)
            findings.extend(web_vulns)

        elif scan_type == "network_services":
            # AI-guided network service testing
            services = task.parameters.get("services", [])
            network_strategy = await self._get_ai_strategy(
                "vulnerability", "network_services",
                {"services": services}
            )
            network_vulns = await self._perform_network_vulnerability_scan(target, network_strategy)
            findings.extend(network_vulns)

        elif scan_type == "infrastructure":
            # AI-guided infrastructure assessment
            infra_info = task.parameters.get("infrastructure", {})
            infra_strategy = await self._get_ai_strategy(
                "vulnerability", "infrastructure",
                {"infrastructure": infra_info}
            )
            infra_vulns = await self._perform_infrastructure_scan(target, infra_strategy)
            findings.extend(infra_vulns)

        # Generate AI-powered remediation recommendations
        recommendations = await self._generate_vulnerability_recommendations(findings)

        return {
            "findings": findings,
            "recommendations": recommendations,
            "risk_score": self._calculate_vulnerability_risk_score(findings)
        }

    async def _execute_exploitation(self, task: PentestTask) -> Dict[str, Any]:
        """Execute exploitation phase with AI guidance"""
        target = task.target
        vulnerability = task.parameters.get("vulnerability", {})
        findings = []
        recommendations = []

        # AI-guided exploit development
        exploit_strategy = await self._get_ai_strategy(
            "exploitation", "exploit_development",
            {"vulnerability": vulnerability, "target_info": {"target": target}}
        )

        # Simulate exploit execution (in real scenario, this would be actual exploitation)
        exploit_result = await self._simulate_exploitation(target, vulnerability, exploit_strategy)

        if exploit_result.get("success"):
            findings.append({
                "type": "successful_exploitation",
                "vulnerability": vulnerability,
                "access_gained": exploit_result.get("access_level", "unknown"),
                "severity": "critical"
            })

            # Post-exploitation analysis
            if exploit_result.get("access_level") in ["user", "admin", "root"]:
                post_exploit = await self._analyze_post_exploitation_opportunities(
                    target, exploit_result
                )
                findings.extend(post_exploit)

        recommendations = await self._generate_exploitation_recommendations(findings)

        return {
            "findings": findings,
            "recommendations": recommendations,
            "risk_score": self._calculate_exploitation_risk_score(findings)
        }

    async def _execute_post_exploitation(self, task: PentestTask) -> Dict[str, Any]:
        """Execute post-exploitation activities with AI guidance"""
        target = task.target
        access_info = task.parameters.get("access_info", {})
        findings = []
        recommendations = []

        access_level = access_info.get("level", "user")
        system_info = access_info.get("system_info", {})

        # AI-guided privilege escalation
        if access_level != "root":
            priv_esc_strategy = await self._get_ai_strategy(
                "exploitation", "privilege_escalation",
                {"access_level": access_level, "target": target, "system_info": system_info}
            )
            priv_esc_result = await self._analyze_privilege_escalation(target, priv_esc_strategy)
            findings.extend(priv_esc_result)

        # AI-guided lateral movement analysis
        network_info = access_info.get("network_info", {})
        lateral_strategy = await self._get_ai_strategy(
            "exploitation", "lateral_movement",
            {"current_host": target, "network_info": network_info}
        )
        lateral_result = await self._analyze_lateral_movement(target, lateral_strategy)
        findings.extend(lateral_result)

        recommendations = await self._generate_post_exploitation_recommendations(findings)

        return {
            "findings": findings,
            "recommendations": recommendations,
            "risk_score": self._calculate_post_exploitation_risk_score(findings)
        }

    async def _get_ai_strategy(self, phase: str, strategy_type: str, context: Dict[str, Any]) -> str:
        """Get AI-generated strategy for penetration testing phase"""
        prompts = getattr(self, f"{phase}_prompts", {})
        prompt_template = prompts.get(strategy_type, "")

        if not prompt_template:
            return f"Execute {strategy_type} on {context.get('target', 'unknown target')}"

        try:
            # Format prompt with context
            formatted_prompt = prompt_template.format(**context)

            # Simulate AI response (in production, this would call actual AI model)
            ai_response = await self._simulate_ai_response(formatted_prompt, phase, strategy_type)
            return ai_response

        except Exception as e:
            self.logger.error(f"Error getting AI strategy: {str(e)}")
            return f"Standard {strategy_type} approach for {context.get('target', 'target')}"

    async def _simulate_ai_response(self, prompt: str, phase: str, strategy_type: str) -> str:
        """Simulate AI model response for penetration testing guidance"""
        # This is a simulation - in production, integrate with actual AI models
        responses = {
            ("reconnaissance", "subdomain_enum"): """
            Recommended subdomain enumeration strategy:
            1. Use subfinder for passive enumeration
            2. Leverage certificate transparency with crt.sh
            3. Perform DNS brute forcing with custom wordlists
            4. Check for wildcard DNS configurations
            5. Validate discovered subdomains with httpx
            """,

            ("reconnaissance", "port_scanning"): """
            Optimal port scanning approach:
            1. Initial TCP SYN scan: nmap -sS -T4 -p- target
            2. Service detection: nmap -sV -sC -p [discovered_ports] target
            3. UDP scan for critical services: nmap -sU --top-ports 1000 target
            4. Use decoy scanning for evasion if needed
            """,

            ("vulnerability", "web_application"): """
            Web application testing methodology:
            1. Technology fingerprinting and information disclosure
            2. Input validation testing (SQL injection, XSS, XXE)
            3. Authentication and session management testing
            4. Business logic vulnerability assessment
            5. File upload and inclusion vulnerability testing
            """,

            ("exploitation", "exploit_development"): """
            Exploitation strategy:
            1. Analyze vulnerability technical details and affected components
            2. Develop proof-of-concept exploit with appropriate payloads
            3. Test exploit reliability and implement evasion techniques
            4. Plan post-exploitation activities for maximum impact demonstration
            """
        }

        key = (phase, strategy_type)
        return responses.get(key, f"AI-generated strategy for {phase} {strategy_type}")

    # Simulation methods for demonstration (replace with actual tools in production)

    async def _perform_subdomain_enumeration(self, target: str, strategy: str) -> List[str]:
        """Simulate subdomain enumeration"""
        await asyncio.sleep(0.1)  # Simulate processing time
        return [f"www.{target}", f"mail.{target}", f"ftp.{target}", f"admin.{target}"]

    async def _perform_port_scanning(self, target: str, strategy: str) -> List[Dict[str, Any]]:
        """Simulate port scanning"""
        await asyncio.sleep(0.1)
        return [
            {"port": 22, "protocol": "tcp", "service": "ssh", "version": "OpenSSH 8.2"},
            {"port": 80, "protocol": "tcp", "service": "http", "version": "Apache 2.4.41"},
            {"port": 443, "protocol": "tcp", "service": "https", "version": "Apache 2.4.41"}
        ]

    async def _perform_service_enumeration(self, target: str, ports: List[Dict[str, Any]], strategy: str) -> List[Dict[str, Any]]:
        """Simulate service enumeration"""
        await asyncio.sleep(0.1)
        services = []
        for port_info in ports:
            services.append({
                "port": port_info["port"],
                "service": port_info["service"],
                "version": port_info["version"],
                "banner": f"{port_info['service']} banner information"
            })
        return services

    async def _perform_web_vulnerability_scan(self, target: str, strategy: str) -> List[Dict[str, Any]]:
        """Simulate web vulnerability scanning"""
        await asyncio.sleep(0.1)
        return [
            {
                "type": "sql_injection",
                "location": f"https://{target}/login.php?id=1",
                "severity": "high",
                "description": "SQL injection vulnerability in login parameter"
            },
            {
                "type": "xss",
                "location": f"https://{target}/search.php?q=test",
                "severity": "medium",
                "description": "Reflected XSS in search parameter"
            }
        ]

    async def _perform_network_vulnerability_scan(self, target: str, strategy: str) -> List[Dict[str, Any]]:
        """Simulate network vulnerability scanning"""
        await asyncio.sleep(0.1)
        return [
            {
                "type": "ssh_weak_cipher",
                "service": "SSH",
                "port": 22,
                "severity": "medium",
                "description": "SSH service allows weak ciphers"
            }
        ]

    async def _perform_infrastructure_scan(self, target: str, strategy: str) -> List[Dict[str, Any]]:
        """Simulate infrastructure vulnerability scanning"""
        await asyncio.sleep(0.1)
        return [
            {
                "type": "ssl_misconfiguration",
                "location": f"https://{target}",
                "severity": "low",
                "description": "SSL/TLS configuration could be improved"
            }
        ]

    async def _simulate_exploitation(self, target: str, vulnerability: Dict[str, Any], strategy: str) -> Dict[str, Any]:
        """Simulate exploitation attempt"""
        await asyncio.sleep(0.1)
        vuln_type = vulnerability.get("type", "unknown")

        if vuln_type in ["sql_injection", "rce", "privilege_escalation"]:
            return {
                "success": True,
                "access_level": "user",
                "method": f"Exploited {vuln_type} vulnerability",
                "evidence": "Command execution confirmed"
            }
        else:
            return {
                "success": False,
                "reason": f"Exploitation of {vuln_type} unsuccessful"
            }

    async def _analyze_post_exploitation_opportunities(self, target: str, exploit_result: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Analyze post-exploitation opportunities"""
        await asyncio.sleep(0.1)
        return [
            {
                "type": "data_discovery",
                "description": "Sensitive files discovered in user directories",
                "severity": "medium"
            },
            {
                "type": "network_access",
                "description": "Access to internal network segments",
                "severity": "high"
            }
        ]

    async def _analyze_privilege_escalation(self, target: str, strategy: str) -> List[Dict[str, Any]]:
        """Analyze privilege escalation opportunities"""
        await asyncio.sleep(0.1)
        return [
            {
                "type": "sudo_misconfiguration",
                "description": "Sudo configuration allows privilege escalation",
                "severity": "high"
            }
        ]

    async def _analyze_lateral_movement(self, target: str, strategy: str) -> List[Dict[str, Any]]:
        """Analyze lateral movement opportunities"""
        await asyncio.sleep(0.1)
        return [
            {
                "type": "credential_reuse",
                "description": "Discovered credentials can access other systems",
                "severity": "high"
            }
        ]

    # Recommendation generation methods

    async def _generate_reconnaissance_recommendations(self, findings: List[Dict[str, Any]]) -> List[str]:
        """Generate AI-powered reconnaissance recommendations"""
        recommendations = []

        for finding in findings:
            if finding["type"] == "subdomain_discovery":
                recommendations.append("Implement proper subdomain management and monitoring")
            elif finding["type"] == "open_ports":
                recommendations.append("Review and minimize exposed services")
            elif finding["type"] == "service_discovery":
                recommendations.append("Ensure all services are properly configured and updated")

        return recommendations

    async def _generate_vulnerability_recommendations(self, findings: List[Dict[str, Any]]) -> List[str]:
        """Generate AI-powered vulnerability remediation recommendations"""
        recommendations = []

        for finding in findings:
            if finding["type"] == "sql_injection":
                recommendations.append("Implement parameterized queries and input validation")
            elif finding["type"] == "xss":
                recommendations.append("Implement output encoding and Content Security Policy")
            elif finding["type"] == "ssl_misconfiguration":
                recommendations.append("Update SSL/TLS configuration to use secure protocols")

        return recommendations

    async def _generate_exploitation_recommendations(self, findings: List[Dict[str, Any]]) -> List[str]:
        """Generate exploitation-based security recommendations"""
        recommendations = [
            "Implement defense-in-depth security measures",
            "Deploy endpoint detection and response (EDR) solutions",
            "Regular security assessments and penetration testing",
            "Incident response plan development and testing"
        ]
        return recommendations

    async def _generate_post_exploitation_recommendations(self, findings: List[Dict[str, Any]]) -> List[str]:
        """Generate post-exploitation security recommendations"""
        recommendations = [
            "Implement network segmentation and access controls",
            "Deploy privileged access management (PAM) solutions",
            "Enhanced logging and monitoring for lateral movement detection",
            "Regular privilege reviews and access audits"
        ]
        return recommendations

    # Risk scoring methods

    def _calculate_reconnaissance_risk_score(self, findings: List[Dict[str, Any]]) -> float:
        """Calculate risk score for reconnaissance findings"""
        score = 0.0
        for finding in findings:
            if finding["type"] == "subdomain_discovery":
                score += len(finding.get("subdomains", [])) * 0.1
            elif finding["type"] == "open_ports":
                score += len(finding.get("ports", [])) * 0.2
            elif finding["type"] == "service_discovery":
                score += len(finding.get("services", [])) * 0.3
        return min(score, 10.0)

    def _calculate_vulnerability_risk_score(self, findings: List[Dict[str, Any]]) -> float:
        """Calculate risk score for vulnerability findings"""
        severity_scores = {"critical": 4.0, "high": 3.0, "medium": 2.0, "low": 1.0}
        score = sum(severity_scores.get(f.get("severity", "low"), 1.0) for f in findings)
        return min(score, 10.0)

    def _calculate_exploitation_risk_score(self, findings: List[Dict[str, Any]]) -> float:
        """Calculate risk score for exploitation findings"""
        score = 0.0
        for finding in findings:
            if finding["type"] == "successful_exploitation":
                access_level = finding.get("access_gained", "user")
                if access_level == "root":
                    score += 5.0
                elif access_level == "admin":
                    score += 4.0
                elif access_level == "user":
                    score += 3.0
        return min(score, 10.0)

    def _calculate_post_exploitation_risk_score(self, findings: List[Dict[str, Any]]) -> float:
        """Calculate risk score for post-exploitation findings"""
        severity_scores = {"critical": 4.0, "high": 3.0, "medium": 2.0, "low": 1.0}
        score = sum(severity_scores.get(f.get("severity", "medium"), 2.0) for f in findings)
        return min(score, 10.0)

class PentestGPTOrchestrator:
    """Orchestrates PentestGPT operations across the AegisLearner-AI platform"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.logger = logging.getLogger(__name__)
        self.pentestgpt_agent = PentestGPTAgent(config)
        self.task_queue = asyncio.Queue()
        self.results_cache = {}

    async def execute_ai_guided_pentest(
        self,
        target: str,
        test_types: List[str],
        parameters: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """Execute comprehensive AI-guided penetration test"""
        if parameters is None:
            parameters = {}

        results = {
            "target": target,
            "test_types": test_types,
            "phases": {},
            "overall_risk_score": 0.0,
            "recommendations": [],
            "execution_summary": {}
        }

        total_risk = 0.0
        phase_count = 0

        # Execute each requested test type
        for test_type in test_types:
            try:
                task = PentestTask(
                    task_id=f"{test_type}_{target}_{datetime.utcnow().timestamp()}",
                    task_type=test_type,
                    target=target,
                    parameters=parameters.get(test_type, {})
                )

                phase_result = await self.pentestgpt_agent.execute_pentest_task(task)

                if phase_result.success:
                    results["phases"][test_type] = {
                        "findings": phase_result.findings,
                        "recommendations": phase_result.recommendations,
                        "risk_score": phase_result.risk_score,
                        "execution_time": phase_result.execution_time
                    }

                    total_risk += phase_result.risk_score
                    phase_count += 1
                    results["recommendations"].extend(phase_result.recommendations)
                else:
                    results["phases"][test_type] = {
                        "error": phase_result.error_message,
                        "success": False
                    }

            except Exception as e:
                self.logger.error(f"Error executing {test_type} for {target}: {str(e)}")
                results["phases"][test_type] = {
                    "error": str(e),
                    "success": False
                }

        # Calculate overall metrics
        results["overall_risk_score"] = total_risk / max(phase_count, 1)
        results["execution_summary"] = {
            "successful_phases": phase_count,
            "total_phases": len(test_types),
            "success_rate": phase_count / len(test_types) if test_types else 0,
            "total_findings": sum(
                len(phase.get("findings", []))
                for phase in results["phases"].values()
                if isinstance(phase, dict) and "findings" in phase
            )
        }

        # Remove duplicate recommendations
        results["recommendations"] = list(set(results["recommendations"]))

        return results

    def get_pentest_capabilities(self) -> Dict[str, Any]:
        """Get available PentestGPT capabilities"""
        return {
            "supported_phases": [
                "reconnaissance",
                "vulnerability_scan",
                "exploitation",
                "post_exploitation"
            ],
            "ai_models": [
                "GPT-4 for strategic planning",
                "GPT-3.5 for tactical execution",
                "Custom security models for specific techniques"
            ],
            "integration_features": [
                "Automated tool selection",
                "Dynamic strategy adaptation",
                "Intelligent result correlation",
                "Risk-based prioritization"
            ],
            "supported_targets": [
                "Web applications",
                "Network infrastructure",
                "Mobile applications",
                "API endpoints",
                "Cloud environments"
            ]
        }

# Factory function for easy integration
def create_pentestgpt_agent(config: Dict[str, Any] = None) -> PentestGPTOrchestrator:
    """Create and configure PentestGPT agent"""
    if config is None:
        config = {
            "ai_model": "gpt-4",
            "max_concurrent_tasks": 5,
            "timeout_seconds": 300,
            "enable_aggressive_testing": False
        }

    return PentestGPTOrchestrator(config)

if __name__ == "__main__":
    # Example usage
    async def main():
        config = {
            "ai_model": "gpt-4",
            "max_concurrent_tasks": 3,
            "timeout_seconds": 600
        }

        orchestrator = create_pentestgpt_agent(config)

        # Execute AI-guided pentest
        result = await orchestrator.execute_ai_guided_pentest(
            target="example.com",
            test_types=["reconnaissance", "vulnerability_scan"],
            parameters={
                "reconnaissance": {"scope": "full"},
                "vulnerability_scan": {"scan_type": "web_application"}
            }
        )

        print(json.dumps(result, indent=2))

        # Show capabilities
        capabilities = orchestrator.get_pentest_capabilities()
        print(f"PentestGPT Capabilities: {json.dumps(capabilities, indent=2)}")

    asyncio.run(main())